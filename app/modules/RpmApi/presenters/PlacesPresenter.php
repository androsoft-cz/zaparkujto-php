<?php

namespace App\Modules\Rpmapi;

use App\Core\Latte\Filters;
use App\Core\Utils\Thumbnails;
use App\Model\Exceptions\RuntimeException;
use App\Model\Facade\PlaceFacade;
use App\Model\Orm\Organizations\Organization;
use App\Model\Orm\Organizations\OrganizationsRepository;
use App\Model\Orm\Places\Place;
use App\Model\Orm\Places\PlacesRepository;
use App\Model\Orm\Places\SearchPlace;
use App\Model\Orm\UseofPlaces\UseofPlaces;
use App\Model\Search\FreeCapacityCounter;
use App\Model\Search\SearchArgs;
use App\Model\Search\PlaceFinder;
use App\Model\Search\UseofPlaceSelector;
use App\Model\TimeLogic\ITimeAnalyzatorFactory;
use Nette\Http\Response;
use Nette\Utils\Random;
use Nette\Utils\Strings;
use App\Core\Utils;
use Nextras\Orm\Collection\ICollection;
use Nextras\Orm\Entity\IEntity;
use stdClass;

class PlacesPresenter extends SecurePresenter
{
    /** @var SearchArgs @inject */
    public $search;

    /** @var PlacesRepository @inject */
    public $placesRepository;

    /** @var OrganizationsRepository @inject */
    public $organizationsRepository;

    /** @var  PlaceFacade @inject */
    public $placeFacade;

    /** @var FreeCapacityCounter @inject */
    public $freeCapacityCounter;

    /** @var PlaceFinder @inject */
    public $placeFinder;

    /** @var UseofPlaceSelector @inject */
    public $useofPlaceSelector;

    /** @var ITimeAnalyzatorFactory @inject */
    public $timeAnalyzatorFactory;

    private $xdevlat;

    private $xdevlng;


    public function startup(): void
    {
        parent::startup(); // TODO: Change the autogenerated stub

        $httpRequest = $this->getHttpRequest();
        $this->xdevlat = $httpRequest->getHeader('X-Device-Lat');
        $this->xdevlng = $httpRequest->getHeader('X-Device-Lng');
    }


    /**
     * Add new place
     *
     * @param array $query
     * @param mixed $data
     */
    public function actionCreate($data): void
    {
        $d = json_decode($data);

        if (!$d) {
            $this->sendError('Request body is not in our JSON format. Call me, baby!', Response::S400_BAD_REQUEST);
        }

        try {
            /** @var Place $place */
            $place = new Place();
            $place->smsKeyword = Strings::upper(Random::generate(6));
            $place->identifier = $d->identifier;
            $place->capacity = $d->capacity;
            $place->lat = $d->lat;
            $place->lng = $d->lng;
            //$place->name = $d->name;
            $place->description = $d->description;
            $place->streetName = $d->street_name;
            $place->locationRadius = $d->location_radius;
            $place->sparePlace = NULL;
            $place->deletedAt = NULL;

            /** @var Organization $organization */
            $organization = $this->organizationsRepository->getById($this->organizationId);
            $place->organization = $organization;

            $this->placesRepository->persistAndFlush($place);

            $results = [
                'result' => 'ok',
                'place_id' => $place->id,
            ];

            $this->sendApiResponse($results);
        } catch (\ErrorException $e) {
            $this->sendError('Error while saving data!' . $e->getMessage(), Response::S400_BAD_REQUEST);
        }
    }


    /**
     * Place detail information
     *
     * @param       $id
     * @param array $query
     */
    public function actionRead($id, array $query): void
    {
        if (!$id) {
            $this->sendError('Request body is not in our JSON format. ID is not set', Response::S400_BAD_REQUEST);
        }

        /** @var Place $place */
        $place = $this->placesRepository->getById($id);
        if (!$place) {
            $exception = (new RuntimeException('Place not found.'))->setApiMessage('itemNotFound');
            $this->sendErrorByException($exception);
        }

        $searchArgs = new SearchArgs();
        $searchArgs->reserveFrom = time();
        $useOfPlace = $this->useofPlaceSelector->getUseofPlace($place, $searchArgs);

        if (!$useOfPlace) {
            $exception = (new RuntimeException('UseofPlace not found.'))->setApiMessage('itemNotFound');
            $this->sendErrorByException($exception);
        }

        $width = $query['width'] ?? NULL;
        $height = $query['height'] ?? NULL;

        if (!$width) {
            $imagePath = 'data/places/' . $id . '/cover.jpg';

            if (file_exists($imagePath)) {
                $type = pathinfo($imagePath, PATHINFO_EXTENSION);

                if ($width === 0) {
                    $data = file_get_contents($imagePath);
                } else {
                    $thumb = new Thumbnails('');
                    $thumbfile = $thumb->getThumbName($imagePath, $width, $height, 0);
                    if (file_exists($thumbfile)) {
                        $data = file_get_contents($thumbfile);
                    } else {
                        $thumbfile = $thumb->thumb($imagePath, $width, $height);
                        $data = file_get_contents($thumbfile);
                    }
                }

                $base64 = 'data:image/' . $type . ';base64,' . base64_encode($data);
            } else {
                $base64 = NULL;
            }
        } else {
            $base64 = NULL;
        }

        $coordinates = $this->getAuthorativeCoordinates($query);
        $distance = 0;
        if ($coordinates->lat && $coordinates->lng) {
            $distance = Utils\LngLat::haversineGreatCircleDistance($place->lat, $place->lng, $coordinates->lat, $coordinates->lng) / 1000;
        }

        // Stored payment cards to pay with
        if (!$place->organization->paymentGateway->storeCard) {
            $paymentCards = FALSE;
        } else {
            $paymentCards = $place->organization->paymentGateway->paymentCards->get()->findBy(['user' => $this->user->id, 'deletedAt' => NULL])->fetchAll();
            foreach ($paymentCards as $key => $paymentCard) {
                $paymentCards[$key] = $paymentCards[$key]->toArray(IEntity::TO_ARRAY_RELATIONSHIP_AS_ID);
                // mask
                unset($paymentCards[$key]['referencePayId']);
                $paymentCards[$key]['createdAt'] = $paymentCards[$key]['createdAt']->format('c');
                $paymentCards[$key]['deletedAt'] = $paymentCards[$key]['deletedAt'] ? $paymentCards[$key]['deletedAt']->format('c') : NULL;
            }
        }

        $results = [
            'id' => $place->id,
            'street_name' => $place->streetName,
            'identifier' => $place->identifier,
            'description' => $place->description,
            'lng' => $place->lng,
            'lat' => $place->lat,
            'price_per_unit' => $useOfPlace->pricePerUnit,
            'price_per_extend' => $useOfPlace->pricePerExtend,
            'max_reservation_time' => $useOfPlace->maxReservationTime,
            'capacity' => $place->capacity,
            'free_capacity' => $this->freeCapacityCounter->count($place, $useOfPlace, $searchArgs),
            'advance_reservation' => FALSE, // todo: zrusit
            'type' => $useOfPlace->type,
            'demo' => $place->organization->demo,
            'for_free' => $useOfPlace->isForFree(),
            'distance' => $distance,
            'canWeCountFreePlaces' => $place->countFreePlaces,
            'thumbnail' => $base64,
            'paymentCards' => $paymentCards,
        ];

        $this->sendApiResponse($results);
    }


    /**
     * List of places
     */
    public function actionReadAll(array $query): void
    {
        try {
            $coordinates = $this->getAuthorativeCoordinates($query);
            $q = $query['q'] ?? NULL;

            if (isset($query['types'])) {
                $types = empty($query['types']) ? UseofPlaces::TYPE_NOT_PROSPECT : $query['types'];
            } else {
                $types = UseofPlaces::TYPE_NOT_PROSPECT;
            }

            // Pass search arguments
            $this->search->reserveFrom = time();
            $this->search->q = $q;
            $this->search->lat = $coordinates->lat;
            $this->search->lng = $coordinates->lng;
            $this->search->type = $types;

            // Search places
            $places = $this->placeFinder->find($this->search, 20);

            // Create time analyzator (by search arguments)
            $analyzator = $this->timeAnalyzatorFactory->create($this->search);

            $this->template->search = $this->search;

            $results = [];

            /** @var SearchPlace $r */
            foreach ($places as $r) {
                if (isset($r->members)) {
                    $isPlaceMember = $this->placesRepository->isPlaceMember($r->id, $this->user->identity->username);
                    if ($isPlaceMember == 1) {
                        $showPlace = TRUE;
                    } else {
                        $showPlace = FALSE;
                    }
                } else {
                    $showPlace = TRUE;
                }

                if ($showPlace) {
                    $free = $analyzator->getFreeEntry($r);
                    $park = $analyzator->getParkEntry($r);
                    $is_free = $free->isFreeIn() ? 'in' : 'now';
                    $is_park = $park->isParkLong() ? 'long' : 'until';

                    $results[] = [
                        'id' => $r->id,
                        'organization_id' => $r->organization->id,
                        'street_name' => $r->streetName,
                        'identifier' => $r->identifier,
                        'description' => $r->description,
                        'lng' => $r->lng,
                        'lat' => $r->lat,
                        'price_per_unit' => $r->matchingUseofPlace->pricePerUnit,
                        'price_per_extend' => $r->matchingUseofPlace->pricePerExtend,
                        'free_text' => $free->isFreeNow() ? 'Volno hned' : 'Volno za ' . $free->date->format('i') . ' min',
                        'is_free_now' => $free->isFreeNow(),
                        'is_free' => $is_free,
                        'park_text' => $park->isParkLong() ? '> ' . Filters::hours($park->date, $this->search->datetime) : 'do ' . $park->date->format('G:i'),
                        'park_duration' => $park->isParkLong(),
                        'park_duration_end' => $park->date,
                        'is_park' => $is_park,
                        'free_from_date' => $free->date->format('c'),
                        'free_to_date' => $park->date->format('c'),
                        'max_reservation_time' => $r->matchingUseofPlace->maxReservationTime,
                        'capacity' => $r->capacity,
                        'free_capacity' => $r->freeCapacity,
                        'advance_reservation' => FALSE, // todo: zrusit
                        'type' => $r->matchingUseofPlace->type,
                        'for_free' => $r->matchingUseofPlace->isForFree(),
                        'demo' => $r->organization->demo,
                        'distance' => $r->distance,
                        'canWeCountFreePlaces' => $r->countFreePlaces,
                        'thumbnail' => NULL,
                    ];
                }
            }

            $this->sendApiResponse($results);
        } catch (\ErrorException $e) {
            $this->sendError($e->getMessage(), Response::S400_BAD_REQUEST);
        }
    }


    private function getAuthorativeCoordinates(array $query): stdClass
    {
        $result = new stdClass();
        $result->lat = $query['lat'] ?? $query['my_lat'] ?? $this->xdevlat ?? NULL;
        $result->lng = $query['lng'] ?? $query['my_lng'] ?? $this->xdevlng ?? NULL;
        return $result;
    }
}
